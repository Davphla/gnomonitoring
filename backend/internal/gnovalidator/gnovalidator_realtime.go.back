package gnovalidator

import (
	"database/sql"
	"flag"
	"fmt"
	"log"
	"net/http"
	"sync"
	"time"

	"github.com/gnolang/gno/gno.land/pkg/gnoclient"
	rpcclient "github.com/gnolang/gno/tm2/pkg/bft/rpc/client"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/samouraiworld/gnomonitoring/backend/internal"
	// "github.com/samouraiworld/gnomonitoring/backend/internal/Gnovalidator"
)

// VARIABLE DECLARATION
var TestAlert = flag.Bool("test-alert", false, "Send alert test for Discord")
var MonikerMutex sync.RWMutex
var lastRPCErrorAlert time.Time //anti spam for error RPC

type BlockParticipation struct {
	Height     int64
	Validators map[string]bool
}

var (
	BlockWindow []BlockParticipation
	//windowSize        = 100
	ParticipationRate = make(map[string]float64)
	LastAlertSent     = make(map[string]int64) // to avoid spamming
	MonikerMap        = make(map[string]string)
)

func StartValidatorMonitoring(db *sql.DB) {
	flag.Parse()
	Init()
	// LoadConfig()
	InitMonikerMap()

	if *TestAlert {
		moniker := "g1test123456"
		validator := "xxxxxxxx"
		rate := 42.0
		winsize := 100
		startHeight := 0
		endHeight := 99
		url := "https://discord.com/api/webhooks/1362423744097681458/vslQMyePTF587NZzwD979Q_p8b3xtmlUrKR154liHoGSxTWbILh7Lf4-_Y75W0TFPTV5"
		message := fmt.Sprintf("‚ö†Ô∏è Validator %s (%s) has a participation rate of %.2f%% over the last %d blocks (from block %d to %d).",
			moniker, validator, rate, winsize, startHeight, endHeight)
		internal.SendDiscordAlert(message, url)
		return
	}

	rpcClient, err := rpcclient.NewHTTPClient(internal.Config.RPCEndpoint)
	if err != nil {
		log.Fatalf("Failed to connect to RPC: %v", err)
	}

	client := gnoclient.Client{RPCClient: rpcClient}

	// Initializing the window with the latest blocks

	latestHeight, err := client.LatestBlockHeight()
	if err != nil {
		log.Fatalf("Error retrieving last height: %v", err)
	}

	startHeight := latestHeight - int64(internal.Config.WindowSize) + 1
	if startHeight < 1 {
		startHeight = 1
	}

	for h := startHeight; h <= latestHeight; h++ {
		block, err := client.Block(h)
		if err != nil || block.Block.LastCommit == nil {
			log.Printf("Error block %d: %v", h, err)
			continue
		}

		participating := make(map[string]bool)
		for _, precommit := range block.Block.LastCommit.Precommits {
			if precommit != nil {
				participating[precommit.ValidatorAddress.String()] = true
			}
		}

		BlockWindow = append(BlockWindow, BlockParticipation{
			Height:     h,
			Validators: participating,
		})
	}

	log.Printf("Sliding window initialized to block %d.\n", latestHeight)

	// Start the real-time tracking loop
	go func() {
		lastStored, err := GetLastStoredHeight(db)
		if err != nil {
			log.Printf("‚ö†Ô∏è Database empty get last block: %v", err)
			lastStored, err = client.LatestBlockHeight() // recommence de z√©ro si la BDD est vide
		}

		currentHeight := lastStored + 1
		//currentHeight := latestHeight
		lastProgressHeight := currentHeight
		lastProgressTime := time.Now()
		alertSent := false //for not spam channel
		restoredNotified := false

		for {
			// Get value of the last block
			latest, err := client.LatestBlockHeight()

			if err != nil {
				log.Printf("Recovery error: height: %v", err)

				if time.Since(lastRPCErrorAlert) > 10*time.Minute {
					msg := fmt.Sprintf("‚ö†Ô∏è Error when querying latest block height: %v", err)
					msg += fmt.Sprintf("\nLast known block height: %d", currentHeight)

					// internal.SendDiscordAlertValidator(msg, db)
					// internal.SendSlackAlertValidator(msg, db)

					lastRPCErrorAlert = time.Now()
				}
				//feat / add resolve Recovery Block height
				time.Sleep(10 * time.Second)
				continue
			}

			lastRPCErrorAlert = time.Time{}

			//  Stagnation detection
			if latest == lastProgressHeight {
				if !alertSent && time.Since(lastProgressTime) > 2*time.Minute {
					msg := fmt.Sprintf("‚ö†Ô∏è Blockchain stuck at height %d for more than 2 minutes", latest)
					log.Println(msg)
					internal.SendDiscordAlertValidator(msg, db)
					internal.SendSlackAlertValidator(msg, db)

					alertSent = true
					restoredNotified = false
					lastProgressTime = time.Now()
				}
			} else {
				lastProgressHeight = latest
				lastProgressTime = time.Now()

				//send alert if gnoland return to normal
				if alertSent && !restoredNotified {
					internal.SendDiscordAlertValidator("‚úÖ **Activity Restored**: Gnoland is back to normal.", db)
					internal.SendSlackAlertValidator("‚úÖ *Activity Restored*: Gnoland is back to normal.", db)
					restoredNotified = true
					alertSent = false
				}
			}

			if latest <= currentHeight {
				time.Sleep(3 * time.Second)
				continue
			}

			log.Println("last block ", latest)
			// Load new blocks (if more than one at a time)

			for h := currentHeight + 1; h <= latest; h++ {

				//Check if have a news validator
				if h%100 == 0 {
					log.Println("üîÅ Refresh MonikerMap after 100 blocks")

					// Copy snapshot before update
					oldMap := make(map[string]string)
					MonikerMutex.RLock()
					for k, v := range MonikerMap {
						oldMap[k] = v
					}
					MonikerMutex.RUnlock()

					// Update
					InitMonikerMap()

					// Comparaison of news and old moniker map for detected a news validator
					MonikerMutex.RLock()
					for addr, moniker := range MonikerMap {
						if _, exists := oldMap[addr]; !exists {
							msg := fmt.Sprintf("**‚úÖ News Validator %s addr: %s  **", addr, moniker)
							msgS := fmt.Sprintf("*‚úÖ News Validator %s addr: %s  *", addr, moniker)
							log.Println(msg)
							internal.SendDiscordAlertValidator(msg, db)
							internal.SendSlackAlertValidator(msgS, db)

						}
					}
					MonikerMutex.RUnlock()
				}

				// end of initMoniker of x block

				block, err := client.Block(h)
				println(block)
				if err != nil || block.Block.LastCommit == nil {
					log.Printf("Erreur bloc %d: %v", h, err)
					continue
				}

				participating := make(map[string]bool)
				for _, precommit := range block.Block.LastCommit.Precommits {
					if precommit != nil {
						participating[precommit.ValidatorAddress.String()] = true
					}
				}
				// Ins√®re la participation pour chaque validateur dans la base de donn√©es
				today := time.Now().Format("2006-01-02")
				for valAddr, moniker := range MonikerMap {
					_, participated := participating[valAddr]
					stmt := `INSERT OR REPLACE INTO daily_participation(date, block_height, moniker, addr, participated) VALUES (?, ?, ?, ?, ?)`
					_, err := db.Exec(stmt, today, h, moniker, valAddr, participated)
					if err != nil {
						log.Printf("Error saving participation for %s: %v", valAddr, err)
					}
				}

				BlockWindow = append(BlockWindow, BlockParticipation{
					Height:     h,
					Validators: participating,
				})
				if len(BlockWindow) > internal.Config.WindowSize {
					BlockWindow = BlockWindow[1:]
				}

				log.Printf("Block %d added to window", h)

				//Calculation of participation rates
				validatorCounts := make(map[string]int)
				for _, bp := range BlockWindow {
					for val := range bp.Validators {
						validatorCounts[val]++
					}
				}

				start := BlockWindow[0].Height
				end := BlockWindow[len(BlockWindow)-1].Height

				// for prometheus
				BlockWindowStartHeight.Set(float64(start))
				BlockWindowEndHeight.Set(float64(end))

				for val, moniker := range MonikerMap {
					count := validatorCounts[val]
					rate := float64(count) / float64(len(BlockWindow)) * 100
					ParticipationRate[val] = rate

					log.Printf("Validator %s (%s) : %.2f%% \n", val, moniker, rate)
					ValidatorParticipation.WithLabelValues(val, moniker).Set(rate)
					if rate < 100 {
						if LastAlertSent[val] < h-int64(internal.Config.WindowSize) {
							message := fmt.Sprintf("‚ö†Ô∏è Validator %s (%s) has a participation rate of %.2f%% over the last %d blocks (from block %d to %d).",
								moniker, val, rate, internal.Config.WindowSize, start, end)
							internal.SendDiscordAlertValidator(message, db)
							internal.SendSlackAlertValidator(message, db)

							LastAlertSent[val] = h
						}
					}
				}
			}

			currentHeight = latest
		}
	}()

	// Exposure Prometheus
	http.Handle("/metrics", promhttp.Handler())
	log.Println("Prometheus metrics available on :8888/metrics")
	//log.Fatal(http.ListenAndServe(":8888", nil))
	addr := fmt.Sprintf(":%d", internal.Config.MetricsPort)
	log.Printf("Prometheus metrics available on %s/metrics", addr)
	log.Fatal(http.ListenAndServe(addr, nil))

}
