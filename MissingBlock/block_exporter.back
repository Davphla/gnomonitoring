package main

import (
	"encoding/json"
	"log"
	"net/http"
	"os"
	"strconv"
	"time"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"gopkg.in/yaml.v3"
)

// Structure de la configuration
type Config struct {
	ValidatorAddress string `yaml:"validator_address"`
}

var config Config

// Structures pour le parsing JSON
type StatusResponse struct {
	Result struct {
		SyncInfo struct {
			LatestBlockHeight string `json:"latest_block_height"`
		} `json:"sync_info"`
	} `json:"result"`
}

type ValidatorResponse struct {
	Result struct {
		ValidatorInfo struct {
			SignedBlocks int `json:"signed_blocks"`
		} `json:"validator_info"`
	} `json:"result"`
}

// Définition des métriques Prometheus
var (
	totalBlocks = prometheus.NewGauge(prometheus.GaugeOpts{
		Name: "gnoland_total_blocks",
		Help: "Total number of blocks received by the validator",
	})

	signedBlocks = prometheus.NewGauge(prometheus.GaugeOpts{
		Name: "gnoland_signed_blocks",
		Help: "Total number of blocks signed by the validator",
	})

	missedBlocks = prometheus.NewGauge(prometheus.GaugeOpts{
		Name: "gnoland_missed_blocks",
		Help: "Total number of blocks missed by the validator",
	})
)

// Charger la configuration depuis un fichier YAML
func loadConfig() {
	bytes, err := os.ReadFile("config.yaml") // Utilisation de os.ReadFile
	if err != nil {
		log.Fatalf("Error reading config file: %v", err)
	}

	err = yaml.Unmarshal(bytes, &config)
	if err != nil {
		log.Fatalf("Error parsing YAML: %v", err)
	}
	log.Println("Configuration loaded:", config)
}

// Fonction pour récupérer les métriques
func fetchMetrics() {
	// Récupérer l'état général du validateur (numéro de bloc)
	statusURL := config.ValidatorAddress + "/status"
	statusResp, err := http.Get(statusURL)
	if err != nil {
		log.Println("Error fetching status from RPC:", err)
		return
	}
	defer statusResp.Body.Close()

	var status StatusResponse
	if err := json.NewDecoder(statusResp.Body).Decode(&status); err != nil {
		log.Println("Error decoding status JSON:", err)
		return
	}

	// Récupérer les informations spécifiques au validateur (bloc signé)
	validatorURL := config.ValidatorAddress + "/validators"
	validatorResp, err := http.Get(validatorURL)
	if err != nil {
		log.Println("Error fetching validator info from RPC:", err)
		return
	}
	defer validatorResp.Body.Close()

	var validator ValidatorResponse
	if err := json.NewDecoder(validatorResp.Body).Decode(&validator); err != nil {
		log.Println("Error decoding validator JSON:", err)
		return
	}

	// Conversion des chaînes en int
	totalBlocksHeight, err := strconv.Atoi(status.Result.SyncInfo.LatestBlockHeight)
	if err != nil {
		log.Println("Error converting LatestBlockHeight:", err)
		return
	}

	signedBlocksCount := validator.Result.BlockHeight

	// Mise à jour des métriques
	totalBlocks.Set(float64(totalBlocksHeight))
	signedBlocks.Set(float64(signedBlocksCount))
	missedBlocks.Set(float64(totalBlocksHeight - signedBlocksCount))
}

func main() {
	// Charger la configuration
	loadConfig()

	// Enregistrement des métriques
	prometheus.MustRegister(totalBlocks)
	prometheus.MustRegister(signedBlocks)
	prometheus.MustRegister(missedBlocks)

	// Mise à jour des métriques toutes les 10 secondes
	go func() {
		for {
			fetchMetrics()
			log.Println("Metrics updated")
			time.Sleep(10 * time.Second)
		}
	}()

	// Serveur HTTP pour Prometheus
	http.Handle("/metrics", promhttp.Handler())
	log.Println("Starting metrics server on :8888")
	log.Fatal(http.ListenAndServe(":8888", nil))
}
